import './Artboard.svelte.css.proxy.js';
/* src/Artboard.svelte generated by Svelte v3.44.2 */
import {
	SvelteComponent,
	add_flush_callback,
	add_render_callback,
	add_resize_listener,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	safe_not_equal,
	set_style,
	space,
	src_url_equal,
	svg_element,
	transition_in,
	transition_out
} from "../_snowpack/pkg/svelte/internal.js";

import Grid from "../_snowpack/pkg/svelte-grid.js";
import Thumbnail from './Thumbnail.svelte.js';
import gridHelp from "../_snowpack/pkg/svelte-grid/build/helper/index.js";
import { mainText } from './BottomNav.svelte.js';

function create_if_block(ctx) {
	let grid;
	let updating_items;
	let current;

	function grid_items_binding(value) {
		/*grid_items_binding*/ ctx[7](value);
	}

	let grid_props = {
		throttleUpdate: 100,
		fillSpace: false,
		rowHeight: /*artboardW*/ ctx[0] / 34,
		gap: [0, 0],
		cols: /*cols*/ ctx[6],
		$$slots: {
			default: [
				create_default_slot,
				({ item, dataItem }) => ({ 11: item, 12: dataItem }),
				({ item, dataItem }) => (item ? 2048 : 0) | (dataItem ? 4096 : 0)
			]
		},
		$$scope: { ctx }
	};

	if (/*items*/ ctx[2] !== void 0) {
		grid_props.items = /*items*/ ctx[2];
	}

	grid = new Grid({ props: grid_props });
	binding_callbacks.push(() => bind(grid, 'items', grid_items_binding));
	grid.$on("change", /*handleChange*/ ctx[4]);

	return {
		c() {
			create_component(grid.$$.fragment);
		},
		m(target, anchor) {
			mount_component(grid, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const grid_changes = {};
			if (dirty & /*artboardW*/ 1) grid_changes.rowHeight = /*artboardW*/ ctx[0] / 34;

			if (dirty & /*$$scope, dataItem*/ 12288) {
				grid_changes.$$scope = { dirty, ctx };
			}

			if (!updating_items && dirty & /*items*/ 4) {
				updating_items = true;
				grid_changes.items = /*items*/ ctx[2];
				add_flush_callback(() => updating_items = false);
			}

			grid.$set(grid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(grid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(grid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(grid, detaching);
		}
	};
}

// (48:2) <Grid bind:items={items} on:change={handleChange} throttleUpdate={100} fillSpace={false} rowHeight={artboardW/34} gap={[0, 0]} let:item let:dataItem {cols}>
function create_default_slot(ctx) {
	let div;
	let img;
	let img_id_value;
	let img_src_value;

	return {
		c() {
			div = element("div");
			img = element("img");
			attr(img, "id", img_id_value = /*dataItem*/ ctx[12].id);
			if (!src_url_equal(img.src, img_src_value = /*imageURL*/ ctx[3](/*dataItem*/ ctx[12].type, /*dataItem*/ ctx[12].font))) attr(img, "src", img_src_value);
			attr(img, "class", "svelte-id4hsm");
			attr(div, "class", "grid-item svelte-id4hsm");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
		},
		p(ctx, dirty) {
			if (dirty & /*dataItem*/ 4096 && img_id_value !== (img_id_value = /*dataItem*/ ctx[12].id)) {
				attr(img, "id", img_id_value);
			}

			if (dirty & /*dataItem*/ 4096 && !src_url_equal(img.src, img_src_value = /*imageURL*/ ctx[3](/*dataItem*/ ctx[12].type, /*dataItem*/ ctx[12].font))) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let container;
	let svg;
	let rect;
	let t0;
	let container_resize_listener;
	let t1;
	let thumbnail;
	let current;
	let if_block = /*artboardW*/ ctx[0] > 0 && create_if_block(ctx);

	thumbnail = new Thumbnail({
			props: {
				items: /*items*/ ctx[2],
				imageURL: /*imageURL*/ ctx[3],
				sessionID: /*sessionID*/ ctx[5]
			}
		});

	return {
		c() {
			container = element("container");
			svg = svg_element("svg");
			rect = svg_element("rect");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(thumbnail.$$.fragment);
			attr(rect, "x", "-500");
			attr(rect, "y", "-500");
			attr(rect, "width", "1000");
			attr(rect, "height", "1000");
			attr(rect, "filter", " url(#pencilTexture5)");
			set_style(rect, "fill", "var(--artboardColor)");
			set_style(rect, "stroke-width", "1");
			set_style(rect, "stroke", "black");
			set_style(rect, "opacity", "1");
			attr(svg, "preserveAspectRatio", "xMidYMid slice");
			attr(svg, "id", "svgArtboard");
			attr(svg, "width", "775");
			attr(svg, "height", "775");
			attr(svg, "viewBox", "-500 -500 1000 1000");
			attr(svg, "class", "svelte-id4hsm");
			attr(container, "class", "svelte-id4hsm");
			add_render_callback(() => /*container_elementresize_handler*/ ctx[8].call(container));
		},
		m(target, anchor) {
			insert(target, container, anchor);
			append(container, svg);
			append(svg, rect);
			append(container, t0);
			if (if_block) if_block.m(container, null);
			container_resize_listener = add_resize_listener(container, /*container_elementresize_handler*/ ctx[8].bind(container));
			insert(target, t1, anchor);
			mount_component(thumbnail, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*artboardW*/ ctx[0] > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*artboardW*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(container, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const thumbnail_changes = {};
			if (dirty & /*items*/ 4) thumbnail_changes.items = /*items*/ ctx[2];
			thumbnail.$set(thumbnail_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(thumbnail.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(thumbnail.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(container);
			if (if_block) if_block.d();
			container_resize_listener();
			if (detaching) detach(t1);
			destroy_component(thumbnail, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let artboardW = 0, artboardH = 0;
	let cached = null;

	mainText.subscribe(val => {
		if (cached) {
			let newItems = [];
			var reg = /[^a-zA-Z~]+/g;
			let words = val.replace(reg, "").split(" ");
			let font = val.includes('GOOO') ? 'jelly' : 'bold';
			let letterCount = 0;
			let rowCount = 0;

			words.forEach((word, i) => {
				let letters = word.split("");

				letters.forEach((letter, j) => {
					let row = Math.floor(letterCount / 4);
					console.log(row);
					let newX = 1 + Math.max(8 * j - 8 * row * 4, 0);
					console.log(newX);

					newItems.push({
						34: gridHelp.item({
							x: newX,
							y: 3 + 10 * row,
							w: 8,
							h: 8,
							resizable: false,
							draggable: true,
							fixed: false
						}),
						id: id(),
						type: letter.toUpperCase(),
						font
					});

					letterCount += 1;
				});
			});

			$$invalidate(2, items = newItems);
			console.log(items);
		}

		cached = val;
	});

	const id = () => "_" + Math.random().toString(36).substr(2, 9);
	const imageURL = (e, font) => './fonts/' + font + '/' + e + '.png';

	const handleChange = e => {
		
	};

	let sessionID = id();

	let items = [
		{
			34: gridHelp.item({
				x: 1,
				y: 3,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'S',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 9,
				y: 3,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'H',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 17,
				y: 3,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'E',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 25,
				y: 3,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'E',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 1,
				y: 23,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'E',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 9,
				y: 23,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'E',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 17,
				y: 23,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'S',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 25,
				y: 23,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'H',
			font: 'bold'
		},
		{
			34: gridHelp.item({
				x: 1,
				y: 13,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'heart',
			font: 'symbols'
		},
		{
			34: gridHelp.item({
				x: 9,
				y: 13,
				w: 16,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'sunglasses',
			font: 'symbols'
		},
		{
			34: gridHelp.item({
				x: 25,
				y: 13,
				w: 8,
				h: 8,
				resizable: false,
				draggable: true,
				fixed: false
			}),
			id: id(),
			type: 'heart',
			font: 'symbols'
		}
	];

	let cols = [[1200, 34]];

	function grid_items_binding(value) {
		items = value;
		$$invalidate(2, items);
	}

	function container_elementresize_handler() {
		artboardW = this.clientWidth;
		artboardH = this.clientHeight;
		$$invalidate(0, artboardW);
		$$invalidate(1, artboardH);
	}

	return [
		artboardW,
		artboardH,
		items,
		imageURL,
		handleChange,
		sessionID,
		cols,
		grid_items_binding,
		container_elementresize_handler
	];
}

class Artboard extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Artboard;